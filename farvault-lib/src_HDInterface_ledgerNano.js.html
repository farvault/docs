<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>src/HDInterface/ledgerNano.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/farvault/farvault-lib" target="_blank" class="menu-item" id="repository" >Farvault-lib Github repo</a></h2><h3>Classes</h3><ul><li><a href="Discovery.html">Discovery</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Discovery.html#fetch">fetch</a></li><li data-type='method' style='display: none;'><a href="Discovery.html#fetchUtxos">fetchUtxos</a></li><li data-type='method' style='display: none;'><a href="Discovery.html#getAccounts">getAccounts</a></li><li data-type='method' style='display: none;'><a href="Discovery.html#getFundedDerivationPaths">getFundedDerivationPaths</a></li><li data-type='method' style='display: none;'><a href="Discovery.html#getNetworkIds">getNetworkIds</a></li><li data-type='method' style='display: none;'><a href="Discovery.html#getUsedDerivationPaths">getUsedDerivationPaths</a></li><li data-type='method' style='display: none;'><a href="Discovery.html#getUtxos">getUtxos</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-bip44.html">bip44</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-bip44.html#.deriveExtPub">deriveExtPub</a></li><li data-type='method' style='display: none;'><a href="module-bip44.html#.getDerivationPathAddress">getDerivationPathAddress</a></li><li data-type='method' style='display: none;'><a href="module-bip44.html#.getExtPubAddress">getExtPubAddress</a></li><li data-type='method' style='display: none;'><a href="module-bip44.html#.parseDerivationPath">parseDerivationPath</a></li><li data-type='method' style='display: none;'><a href="module-bip44.html#.serializeDerivationPath">serializeDerivationPath</a></li><li data-type='method' style='display: none;'><a href="module-bip44.html#.setExtPubPrefix">setExtPubPrefix</a></li><li data-type='method' style='display: none;'><a href="module-bip44.html#~getExtPubAccountNumber">getExtPubAccountNumber</a></li><li data-type='method' style='display: none;'><a href="module-bip44.html#~getExtPubPurpose">getExtPubPurpose</a></li></ul></li><li><a href="module-bip44_chain.html">bip44/chain</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-bip44_chain.html#.getNextDerivationPath">getNextDerivationPath</a></li><li data-type='method' style='display: none;'><a href="module-bip44_chain.html#~getDefaultAccount">getDefaultAccount</a></li><li data-type='method' style='display: none;'><a href="module-bip44_chain.html#~getLastDerivationPath">getLastDerivationPath</a></li><li data-type='method' style='display: none;'><a href="module-bip44_chain.html#~normalizeDerivationPaths">normalizeDerivationPaths</a></li></ul></li><li><a href="module-check.html">check</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-check.html#.checkAddress">checkAddress</a></li><li data-type='method' style='display: none;'><a href="module-check.html#.checkExtPub">checkExtPub</a></li><li data-type='method' style='display: none;'><a href="module-check.html#.checkFeeEstimates">checkFeeEstimates</a></li><li data-type='method' style='display: none;'><a href="module-check.html#.checkNetwork">checkNetwork</a></li><li data-type='method' style='display: none;'><a href="module-check.html#.checkPurpose">checkPurpose</a></li></ul></li><li><a href="module-coinselect.html">coinselect</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-coinselect.html#.coinselect">coinselect</a></li></ul></li><li><a href="module-dataFetchers.html">dataFetchers</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-dataFetchers.html#.blockstreamFetchAddress">blockstreamFetchAddress</a></li><li data-type='method' style='display: none;'><a href="module-dataFetchers.html#.blockstreamFetchFeeEstimates">blockstreamFetchFeeEstimates</a></li><li data-type='method' style='display: none;'><a href="module-dataFetchers.html#.blockstreamFetchUtxos">blockstreamFetchUtxos</a></li><li data-type='method' style='display: none;'><a href="module-dataFetchers.html#.esploraFetchAddress">esploraFetchAddress</a></li><li data-type='method' style='display: none;'><a href="module-dataFetchers.html#.esploraFetchFeeEstimates">esploraFetchFeeEstimates</a></li><li data-type='method' style='display: none;'><a href="module-dataFetchers.html#.esploraFetchUtxos">esploraFetchUtxos</a></li></ul></li><li><a href="module-fees.html">fees</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-fees.html#.feeRateSampling">feeRateSampling</a></li><li data-type='method' style='display: none;'><a href="module-fees.html#.pickEsploraFeeEstimate">pickEsploraFeeEstimate</a></li></ul></li><li><a href="module-HDInterface.html">HDInterface</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-HDInterface.html#.initHDInterface">initHDInterface</a></li></ul></li><li><a href="module-HDInterface_ledgerNano.html">HDInterface/ledgerNano</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-HDInterface_ledgerNano.html#.createSigners">createSigners</a></li><li data-type='method' style='display: none;'><a href="module-HDInterface_ledgerNano.html#~getUtxoSequence">getUtxoSequence</a></li></ul></li><li><a href="module-networks.html">networks</a><ul class='members'><li data-type='member' style='display: none;'><a href="module-networks.html#.networks">networks</a></li></ul><ul class='methods'><li data-type='method' style='display: none;'><a href="module-networks.html#.getNetworkCoinType">getNetworkCoinType</a></li></ul></li><li><a href="module-scripts.html">scripts</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-scripts.html#.createRelativeTimeLockScript">createRelativeTimeLockScript</a></li><li data-type='method' style='display: none;'><a href="module-scripts.html#.parseRelativeTimeLockScript">parseRelativeTimeLockScript</a></li><li data-type='method' style='display: none;'><a href="module-scripts.html#.unlockScript">unlockScript</a></li><li data-type='method' style='display: none;'><a href="module-scripts.html#~numberEncodeAsm">numberEncodeAsm</a></li><li data-type='method' style='display: none;'><a href="module-scripts.html#~scriptNumberDecode">scriptNumberDecode</a></li></ul></li><li><a href="module-secp256k1.html">secp256k1</a></li><li><a href="module-serialization.html">serialization</a></li><li><a href="module-test.html">test</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-test.html#.fundRegtest">fundRegtest</a></li></ul></li><li><a href="module-transactions.html">transactions</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-transactions.html#.createMultiFeeTransactions">createMultiFeeTransactions</a></li><li data-type='method' style='display: none;'><a href="module-transactions.html#.createTransaction">createTransaction</a></li><li data-type='method' style='display: none;'><a href="module-transactions.html#~createPSBT">createPSBT</a></li><li data-type='method' style='display: none;'><a href="module-transactions.html#~witnessStackToScriptWitness">witnessStackToScriptWitness</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#createFixture">createFixture</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">src/HDInterface/ledgerNano.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module HDInterface/ledgerNano */

import LedgerTransport from '@ledgerhq/hw-transport-webusb';
import LedgerTransportNodejs from '@ledgerhq/hw-transport-node-hid-noevents';
import LedgerAppBtc from '@ledgerhq/hw-app-btc';
import { NATIVE_SEGWIT, NESTED_SEGWIT, LEGACY } from '../constants';
import { getNetworkId, getNetworkCoinType } from '../networks';
import memoize from 'lodash.memoize';
export const WEB_TRANSPORT = 'WEB_TRANSPORT';
export const NODEJS_TRANSPORT = 'NODEJS_TRANSPORT';
import { unlockScript } from '../scripts';

import {
  //  crypto,
  Transaction,
  payments,
  script,
  address,
  networks
} from 'bitcoinjs-lib';

import { checkNetwork, checkPurpose, checkExtPub } from '../check';
import {
  setExtPubPrefix,
  parseDerivationPath,
  deriveExtPub,
  serializeDerivationPath
} from '../bip44';

//https://github.com/LedgerHQ/ledgerjs/issues/122#issuecomment-568265915
async function getApp(transport) {
  var r = await transport.send(0xb0, 0x01, 0x00, 0x00);
  var i = 0;
  var format = r[i++];
  var nameLength = r[i++];
  var name = r.slice(i, (i += nameLength)).toString('ascii');
  var versionLength = r[i++];
  var version = r.slice(i, (i += versionLength)).toString('ascii');
  var flagLength = r[i++];
  var flags = r.slice(i, (i += flagLength));
  return { name, version, flags };
}

export async function init(transport = WEB_TRANSPORT) {
  if (transport !== WEB_TRANSPORT &amp;&amp; transport !== NODEJS_TRANSPORT) {
    throw new Error('Invalid transport');
  }
  let ledgerTransport;
  try {
    ledgerTransport =
      transport === WEB_TRANSPORT
        ? await LedgerTransport.create()
        : await LedgerTransportNodejs.create();
  } catch (error) {
    if (error.id === 'NoDeviceFound') {
      throw new Error(
        'You must be plug in the LedgerNano Device into an USB port and enter the PIN code.'
      );
    } else {
      throw new Error(error);
    }
  }
  const { name, version, flags } = await getApp(ledgerTransport);
  if (name !== 'Bitcoin' &amp;&amp; name !== 'Bitcoin Test') {
    throw new Error(
      name === 'BOLOS'
        ? 'You have correclty plugged in the Ledger Nano device but you must open the Bitcoin App. Please open it and try again.'
        : 'You have correclty plugged in the Ledger Nano device but you must open the Bitcoin App. Please, close the ' +
          name +
          ' App, open Bitcoin and try again.'
    );
  }
  const ledgerAppBtc = new LedgerAppBtc(ledgerTransport);
  ledgerAppBtc.farvaultInternalInformation = {
    instanceId: Date.now(),
    name,
    version
  };
  return { ledgerTransport, ledgerAppBtc };
}

export async function close(ledgerTransport) {
  await ledgerTransport.close();
}

export const getExtPub = memoize(
  async function (
    ledgerAppBtc,
    { purpose, accountNumber, network = networks.bitcoin }
  ) {
    checkPurpose(purpose);
    checkNetwork(network);
    if (!Number.isInteger(accountNumber) || accountNumber &lt; 0)
      throw new Error('Invalid accountNumber');
    if (
      (network === networks.bitcoin &amp;&amp;
        ledgerAppBtc.farvaultInternalInformation.name !== 'Bitcoin') ||
      ((network === networks.regtest || network === networks.testnet) &amp;&amp;
        ledgerAppBtc.farvaultInternalInformation.name !== 'Bitcoin Test')
    ) {
      throw new Error(
        "There is a mismatch between Ledger's Nano App and the network requested."
      );
    }

    const extPub = setExtPubPrefix({
      extPub: await ledgerAppBtc.getWalletXpub({
        path: serializeDerivationPath({
          purpose,
          coinType: getNetworkCoinType(network),
          accountNumber
        }),
        //Ledger only accepts xpub or tpub byte version for xpubVersion as in
        //the original BIP32 implementation
        //bitcoinjs-lib (network.bip32.public) also only references xpub or tpub
        //for network = bitcoin, and network = testnet, respectively
        //Read setExtPubPrefix documentation to understand why this is here.
        //Note that network.bip32.public will be === constants.XPUBVERSION
        //for mainnet and === constants.TPUBVERSION for testnet and regtest
        xpubVersion: network.bip32.public
      }),
      purpose,
      network
    });
    checkExtPub({ extPub, accountNumber, network });
    return extPub;
  },
  //The memoize resolver: how to get a key from the params ->
  (ledgerAppBtc, { purpose, accountNumber, network = networks.bitcoin }) =>
    ledgerAppBtc.farvaultInternalInformation.instanceId.toString() +
    '_' +
    purpose.toString() +
    '_' +
    accountNumber.toString() +
    '_' +
    getNetworkId(network)
);

async function getPublicKey(ledgerAppBtc, path, network = networks.bitcoin) {
  const { purpose, coinType, accountNumber, index, isChange } =
    parseDerivationPath(path);
  if (getNetworkCoinType(network) !== coinType) {
    throw new Error('Network mismatch');
  }
  const extPub = await getExtPub(ledgerAppBtc, {
    purpose,
    accountNumber,
    network
  });
  return deriveExtPub({ extPub, index, isChange, network });
}

/** Tries to obtain the lockTime from an utxo
 *
 * If the utxo has a witnessScript or redeemScript, then it parses the script
 * and checks if this is a script we know how to spend (a relativeTimeLockScript
 * for now)
 *
 * If this is a script that we know how to spend then it returns the appropriate
 * sequence.
 *
 * Otherwise it returns `undefined`.
 *
 * @param {object} ledgerAppBtc A [`'@ledgerhq/hw-app-btc'`](https://github.com/LedgerHQ/ledgerjs/tree/master/packages/hw-app-btc#btc) object
 * @param {object} utxo An utxo like this: `{path, witnessScript}`
 * @returns {number} A bip68 encoded sequence or `undefined`
 *
 */
async function getUtxoSequence(ledgerAppBtc, utxo, network) {
  let sequence = undefined;
  let script = undefined;
  if (typeof utxo.witnessScript === 'string') {
    script = utxo.witnessScript;
  }
  if (typeof utxo.redeemScript === 'string') {
    if (typeof utxo.witnessScript === 'string') {
      throw new Error(
        'Cannot have redeemScript and witnessScript at the same time'
      );
    }
    script = utxo.redeemScript;
  }
  if (typeof script !== 'undefined') {
    const pubkey = await getPublicKey(ledgerAppBtc, utxo.path, network);
    const unlockedScript = unlockScript({ script, pubkey });
    if (unlockedScript === false) {
      throw new Error('It is impossible to unlock this script');
    }
    sequence = unlockedScript.sequence;
  }
  return sequence;
}

/**
 * Pass all the utxos that will be signed. The psbt may have more utxos.
 * Also pass the psbt (still not finalized and unlocking scripts may have
 * not been set yet. Just the basic psbt that can be signed.
 *
 * Read some discussion about the motivation behind this function [here](https://github.com/bitcoinjs/bitcoinjs-lib/issues/1517#issuecomment-1064914601).
 *
 * Utxos must include:
 * * utxo.witnessScript for P2WSH pr P2SH-P2WSH
 * * utxo.redeemScript for P2SH.
 *
 * The sequence is obtained from the locking script in witnessScript and redeemScript
 * by parsing the script and comparing it with the known scripts that this
 * wallet software can spend.
 *
 * @param {object} ledgerAppBtc A [`'@ledgerhq/hw-app-btc'`](https://github.com/LedgerHQ/ledgerjs/tree/master/packages/hw-app-btc#btc) object
 * @param {objects} parameters
 * @param {object} parameters.psbt [bitcoinjs-lib Psbt object](https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/src/psbt.js)
 * @param {string} parameters.utxos[].path Derivation path. F.ex.: `44'/1'/1'/0/0`.
 * @param {string} parameters.utxos[].tx The transaction serialized in hex.
 * @param {number} parameters.utxos[].n The vout index of the tx above.
 * @param {string} [parameters.utxos[].witnessScript] The witnessScript serialized in hex in case the utxo can be redeemed with an unlocking script.
 * @param {object} [parameters.network=networks.bitcoin] {@link module:networks.networks A network}
 */
export async function createSigners(
  ledgerAppBtc,
  { psbt, utxos, network = networks.bitcoin }
) {
  checkNetwork(network);
  if (
    (network === networks.bitcoin &amp;&amp;
      ledgerAppBtc.farvaultInternalInformation.name !== 'Bitcoin') ||
    ((network === networks.regtest || network === networks.testnet) &amp;&amp;
      ledgerAppBtc.farvaultInternalInformation.name !== 'Bitcoin Test')
  ) {
    throw new Error(
      "There is a mismatch between Ledger's Nano App and the network requested."
    );
  }
  const tx = psbt.__CACHE.__TX; //It's a private param. May change in future.

  //See if any of the inputs is segwit. If an input is segwit then the tx
  //is also segwit
  const ledgerInputs = [];

  const segwitInputTypes = [];

  for (const utxo of utxos) {
    if (typeof utxo.path === 'undefined') {
      throw new Error('Must pass a path for signing an input');
    }
    if (utxo.witnessScript &amp;&amp; utxo.redeemScript) {
      throw new Error(
        'Either pass a single utxo.path for P2PKH, P2SH-P2WPKH, P2WPKH. \
        Or utxo.path + utxo.witnessScript for P2WSH/P2SH-P2WSH. \
        Or utxo.path +  utxo.redeemScript for Legacy P2SH.'
      );
    }
    const purpose =
      !utxo.witnessScript &amp;&amp;
      !utxo.redeemScript &amp;&amp;
      parseDerivationPath(utxo.path).purpose;

    const sequence = await getUtxoSequence(ledgerAppBtc, utxo, network);
    let redeemScript;
    if (purpose === NATIVE_SEGWIT || purpose === NESTED_SEGWIT) {
      //The redeemScript for NESTED_SEGWIT and NATIVE_SEGWIT must be p2pkh
      //for some reason?!?!?!?
      //This has been thoroughly tested
      const pubkey = await getPublicKey(ledgerAppBtc, utxo.path, network);
      redeemScript = payments.p2pkh({ pubkey, network }).output.toString('hex');
      segwitInputTypes.push(true);
    } else if (purpose === LEGACY) {
      redeemScript = undefined;
      segwitInputTypes.push(false);
    }
    //Legacy P2SH (not P2SH-P2WSH)
    else if (utxo.redeemScript) {
      redeemScript = utxo.redeemScript;
      segwitInputTypes.push(false);
    }
    //P2WSH or P2SH-P2WSH
    else if (utxo.witnessScript) {
      //Yeah, the redeemScript = witnessScript even for P2SH-P2WSH...
      //This has been thoroughly tested
      redeemScript = utxo.witnessScript;
      segwitInputTypes.push(true);
    } else {
      throw new Error('redeemScript not implemented for this purpose');
    }

    ledgerInputs.push([
      ledgerAppBtc.splitTransaction(
        utxo.tx,
        Transaction.fromHex(utxo.tx).hasWitnesses()
      ),
      utxo.n,
      ...(redeemScript ? [redeemScript] : []),
      ...(sequence ? [sequence] : [])
    ]);
  }
  const ledgerDerivationPaths = utxos.map(utxo => utxo.path);

  const getLedgerTxSignatures = async isSegwit => {
    const ledgerTx = ledgerAppBtc.splitTransaction(tx.toHex(), isSegwit);
    const ledgerOutputScriptHex = ledgerAppBtc
      .serializeTransactionOutputs(ledgerTx)
      .toString('hex');

    const ledgerTxSignatures = await ledgerAppBtc.signP2SHTransaction({
      inputs: ledgerInputs,
      associatedKeysets: ledgerDerivationPaths,
      outputScriptHex: ledgerOutputScriptHex,
      segwit: isSegwit,
      transactionVersion: psbt.version
    });
    return ledgerTxSignatures;
  };
  let ledgerTxSignaturesSegwit, ledgerTxSignaturesLegacy;
  //If one of the inputs was segwit we request the ledger device to sign a
  //segwit tx as if all the utxos were segwit. This is a limitation with
  //signP2SHTransaction. It forces to sign assuming everything is segwit/not seg.
  //Later we will pair the correct signature with the correct utxo
  if (segwitInputTypes.includes(true))
    ledgerTxSignaturesSegwit = await getLedgerTxSignatures(true);
  //If one of the inputs was NOT segwit we request the ledger device to sign a
  //segwit tx as if all the utxos were NOT segwit.
  if (segwitInputTypes.includes(false))
    ledgerTxSignaturesLegacy = await getLedgerTxSignatures(false);

  //This is were we match legacySignatures with legacy utxos and segwitSignatures
  //with segwit utxos:
  const ledgerTxSignatures = [];
  for (let index = 0; index &lt; utxos.length; index++) {
    ledgerTxSignatures.push(
      segwitInputTypes[index]
        ? ledgerTxSignaturesSegwit[index]
        : ledgerTxSignaturesLegacy[index]
    );
  }

  const signers = [];
  for (let index = 0; index &lt; utxos.length; index++) {
    const ledgerSignature = ledgerTxSignatures[index];
    const encodedSignature = segwitInputTypes[index]
      ? Buffer.from(ledgerSignature, 'hex')
      : Buffer.concat([
          Buffer.from(ledgerSignature, 'hex'),
          Buffer.from('01', 'hex') // SIGHASH_ALL
        ]);
    const decoded = script.signature.decode(encodedSignature);
    signers.push(hash => decoded.signature);
  }
  return signers;
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Sun Oct 16 2022 08:06:09 GMT+0200 (Central European Summer Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
